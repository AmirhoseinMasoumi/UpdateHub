// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: updates.sql

package db

import (
	"context"
	"time"
)

const createUpdate = `-- name: CreateUpdate :one
INSERT INTO updates (
  version, path, description, checksum
) VALUES (
  $1, $2, $3, $4
) 
ON CONFLICT (version) DO UPDATE
SET path = EXCLUDED.path,
    description = EXCLUDED.description
RETURNING version, path, description, checksum, date
`

type CreateUpdateParams struct {
	Version     string `json:"version"`
	Path        string `json:"path"`
	Description string `json:"description"`
	Checksum    string `json:"checksum"`
}

func (q *Queries) CreateUpdate(ctx context.Context, arg CreateUpdateParams) (Update, error) {
	row := q.db.QueryRowContext(ctx, createUpdate,
		arg.Version,
		arg.Path,
		arg.Description,
		arg.Checksum,
	)
	var i Update
	err := row.Scan(
		&i.Version,
		&i.Path,
		&i.Description,
		&i.Checksum,
		&i.Date,
	)
	return i, err
}

const deleteUpdate = `-- name: DeleteUpdate :one
DELETE FROM updates 
WHERE version = $1
RETURNING version, path, description, checksum, date
`

func (q *Queries) DeleteUpdate(ctx context.Context, version string) (Update, error) {
	row := q.db.QueryRowContext(ctx, deleteUpdate, version)
	var i Update
	err := row.Scan(
		&i.Version,
		&i.Path,
		&i.Description,
		&i.Checksum,
		&i.Date,
	)
	return i, err
}

const getNextVersion = `-- name: GetNextVersion :one
SELECT version, path, description, checksum, date FROM updates
WHERE version > $1
ORDER BY version ASC
LIMIT 1
`

func (q *Queries) GetNextVersion(ctx context.Context, version string) (Update, error) {
	row := q.db.QueryRowContext(ctx, getNextVersion, version)
	var i Update
	err := row.Scan(
		&i.Version,
		&i.Path,
		&i.Description,
		&i.Checksum,
		&i.Date,
	)
	return i, err
}

const getUpdate = `-- name: GetUpdate :one
SELECT version, path, description, checksum, date FROM updates WHERE version = $1 LIMIT 1
`

func (q *Queries) GetUpdate(ctx context.Context, version string) (Update, error) {
	row := q.db.QueryRowContext(ctx, getUpdate, version)
	var i Update
	err := row.Scan(
		&i.Version,
		&i.Path,
		&i.Description,
		&i.Checksum,
		&i.Date,
	)
	return i, err
}

const listUpdatesBetweenDates = `-- name: ListUpdatesBetweenDates :many
SELECT version, path, description, checksum, date
FROM updates
WHERE date BETWEEN $1 AND $2
`

type ListUpdatesBetweenDatesParams struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

func (q *Queries) ListUpdatesBetweenDates(ctx context.Context, arg ListUpdatesBetweenDatesParams) ([]Update, error) {
	rows, err := q.db.QueryContext(ctx, listUpdatesBetweenDates, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Update{}
	for rows.Next() {
		var i Update
		if err := rows.Scan(
			&i.Version,
			&i.Path,
			&i.Description,
			&i.Checksum,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
